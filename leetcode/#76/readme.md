# LeetCode算法之最小覆盖子串 #76

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。
说明：
如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。
链接：https://leetcode-cn.com/problems/minimum-window-substring/

解题思路：
- 移动窗口
    1. 变量
        left：左指针
        right：右指针
        wind：窗口内键哈希
        need：所需字符哈希
        valid：满足条件的字符个数
        start：起点
        end：终点

    2. 逻辑
        - 外层循环：
            1. 移动right指针，
            2. 判断是否是need需要的，如果是就加1到wind哈希对应字符中，并判断是否已经满足该字符的条件，满足则valid+1；循环至全部遍历完成！
        - 内存循环：
            1. 当valid达到need的size也就是说全部字符的条件都满足的时候，进入内层循环，
            2. 首先对起点和终点进行更新，
            3. 移动左指针，
            4. 对这次被删掉的字符进行判断，如果need中需要，那么就把win哈希内的该字符的数量-1，但是在这之前要对该字符判断是否满足了条件，如果满足了条件删掉了一个那就不满足了对吧？故把valid-1.这样就不满足了条件，从而触发外层循环继续执行，也就是继续扩大，直到最后.
            5. 输出：最终检测end是否为正无穷，如果不为正无穷那就输出这个区域的字符串

